# HashTable
> Our mission is to achieve best performance with the smalles change of code.

### Hardcoding and assembling
By analizing the output of perf, I realized the the significant amount of cpu time is spent on hash function. So, I decided to take it out of template parameter and hardcode in table with inline assembly. To make it work even better, I used the version generated by g++ with -O3 flag.
```C++
unsigned long hash(const char* key){
        unsigned long d = 0;

        asm volatile(R"(
            .intel_syntax noprefix
    
            movsx   rax, BYTE PTR [rdi]
            test    al, al
            je      .L4
            xor     edx, edx
    .L3:
            add     rax, rdx
            add     rdi, 1
            mov     rdx, rax
            sal     rdx, 10
            add     rax, rdx
            mov     rdx, rax
            shr     rdx, 6
            xor     rdx, rax
            movsx   rax, BYTE PTR [rdi]
            test    al, al
            jne     .L3
            lea     rdx, [rdx+rdx*8]
            mov     rax, rdx
            shr     rax, 11
            xor     rax, rdx
            mov     rdx, rax
            sal     rdx, 15
            add     rax, rdx
            jmp .Exit
    
    .L4:
            xor     eax, eax
    .Exit:
            .att_syntax
    )"
        :"=r"(h)
        :"D"(key)
    );

        return h;

}
```
Overall performance improved by 5%

### Selecting Hash Function
Jenkins hash is quite good, as you can see in the diagram above, hovewer it is not the fastest one. So I decided to use a crc32 hash, because of it's great distribution characteristic and hardware support.
```C++
inline unsigned long hash(const char* data){

    unsigned long h = 0;
    asm(R"(
        .intel_syntax noprefix
        lea rax, [%1]
        xor %0, %0
    hashing:
        crc32 %0, byte ptr [rax]
        inc rax
        cmp byte ptr [rax], 0
        jne hashing
        .att_syntax prefix
    )"
        : "=r"(h)
        : "r"(data)
        : "rax", "rcx"
	);    

    return h;
}

```
